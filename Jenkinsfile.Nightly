#!groovy

library 'PipelineTools@RMT-9.3.2'
library 'SCVMMHelpers@3.2.0'


properties ([
    parameters([
        choice(defaultValue: 'DEV', choices: ["DEV","GOLD"], description: 'Build type. GOLD can only be used on release branches.', name: 'buildType'),
        string(name: 'relativityBranch', defaultValue: '', description: 'Set Relativity branch'),
        string(name: 'syncBranch', defaultValue: 'develop', description: '')
    ])
])

// *********
// IMPORTANT
// *********
// Set variable below to the branch name, when you create new release branch!!!
// This should be changed on the release branch
def relativityBranchFallback = "develop"
def raidInstalator = null

node('PolandBuild')
{
    try
    {
        stage ('Checkout')
        {
            scmProps = checkout scm
            step([$class: 'StashNotifier', ignoreUnverifiedSSLPeer: true, commitSha1: scmProps.GIT_COMMIT])
        }
        stage ('Build')
        {
            powershell ".\\build.ps1 buildAndSign -buildConfig Release"
        }
        stage ('Unit Tests')
        {
            powershell ".\\build.ps1 runUnitTests"
        }
        stage ('Integration Tests')
        {
            powershell ".\\build.ps1 runIntegrationTests"
        }
        stage('Install RAID')
        {
            raidInstalator = load "scripts/installRaid.groovy"
            raidInstalator.initializePipeline(this, env, params)
            raidInstalator.prepareSut(relativityBranchFallback)
        }

        stage ('System Tests')
        {
            powershell ".\\build.ps1 runSystemTests -sutAddress $pipelineState.sut.name" + ".kcura.corp"
        }
        
        currentBuild.result = 'SUCCESS'
        step([$class: 'StashNotifier', ignoreUnverifiedSSLPeer: true])
    }
    catch (err)
    {
        currentBuild.result = 'FAILURE'
        echo err.toString()
        
        step([$class: 'StashNotifier', ignoreUnverifiedSSLPeer: true])
    }
    finally
    {
        stage('Cleanup VMs')
		{
            raidInstalator.cleanupVMs()
		}

        if (currentBuild.result != 'SUCCESS')
        {
            withCredentials([string(credentialsId: 'SlackJenkinsIntegrationToken', variable: 'token')])
            {
                message = "${env.BUILD_NUMBER} from *${syncBranch}* failed.\n${env.BUILD_URL}"
                slackSend channel: "#cd_sync_nightly", color: "E8E8E8", message: "${message}", teamDomain: 'kcura-pd', token: token
            }

            if (env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'master')
            {
                sendEmailAboutFailureToTeam()
            }
        }
    }
}

def sendEmailAboutFailureToTeam()
{
    def recipients = 'codigooplomo@relativity.com, buenavistacodingclub@relativity.com'
    sendEmailAboutFailure(recipients)
}

def sendEmailAboutFailure(String recipients)
{
    def subject = "${env.JOB_NAME} - Build ${env.BUILD_DISPLAY_NAME} - Failed! On branch ${env.BRANCH_NAME}"
    def body = """${env.JOB_NAME} - Build - Failed:

Check console output at ${env.BUILD_URL} to view the results."""
    sendEmail(body, subject, recipients)
}

def sendEmail(String body, String subject, String recipients)
{
    emailext attachLog: true, body: body, subject: subject, to: recipients
}

def extractValue(String value, String output)
{
    def matcher = output =~ "!!!$value=(.*)"
    $result =  matcher[0][0].split("=")[1]
    matcher = null
    return $result
}

